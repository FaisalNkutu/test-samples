package ca.medis.web.util.amqp;

import com.ibm.mqlight.api.ClientOptions;
import com.ibm.mqlight.api.Delivery;
import com.ibm.mqlight.api.DestinationAdapter;
import com.ibm.mqlight.api.NonBlockingClient;
import com.ibm.mqlight.api.NonBlockingClientAdapter;
import com.ibm.mqlight.api.StringDelivery;

import ca.medis.web.util.rpg.RpgCallContext;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.apache.log4j.Logger;

/**
 * Create a connection pool factory service
 * 
 * @author: fnkutu
 */
public abstract class AMQPConnectionPool {

    protected static final ExecutorService executorService = Executors.newScheduledThreadPool(2);
    protected final List<NonBlockingClient> clientPool;
    protected int poolSize = 2;
    static Logger logger = Logger.getLogger(AMQPConnectionPool.class.getName());
    protected String host = null;
    protected String userName = null;
    protected String password = null;
    protected String topic = null;
    private String topicToConnectTo = null;
    NonBlockingClient client = null;

    private static final Map<String, NonBlockingClient> connectionPool = new HashMap<>();
    private static final Object poolLock = new Object();

    AMQPConfiguration amqpConfiguration = null;
    private String tpCode;

    public AMQPConnectionPool(RpgCallContext context, String topicToConnectTo, String tpCode) {
        if (poolSize == 0) {
            poolSize = Runtime.getRuntime().availableProcessors();
        }
        this.clientPool = new ArrayList<>(poolSize);
        this.topicToConnectTo = topicToConnectTo;
        this.tpCode = tpCode;
    }

    private void getConfigurationParams() {
        Set<String> tradingPartnerCodes = new HashSet<>();
        try {
            tradingPartnerCodes.add("MSD");
            tradingPartnerCodes.add("CPDN");
            amqpConfiguration = amqpConfiguration.getInstance(tradingPartnerCodes);

            this.topic = amqpConfiguration.getForTrading(tpCode, topicToConnectTo);
            this.host = amqpConfiguration.getForTrading(tpCode, "Host");
            this.userName = amqpConfiguration.getForTrading(tpCode, "Username");
            this.password = amqpConfiguration.getForTrading(tpCode, "Password");

            if (topic == null || host == null || userName == null || password == null) {
                logger.warn("Attempting retry for missing critical configuration parameters.");
                throw new AMQPConfigurationException("Critical AMQP configuration is missing.");
            }

        } catch (AMQPConfigurationException e) {
            logger.error("Critical configuration missing: " + e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("Failed to load configuration settings: " + e.getMessage());
        }
    }

    static NonBlockingClient getClientFromPool(String topic, String host, ClientOptions clientOpts) {
        synchronized (poolLock) {
            return connectionPool.computeIfAbsent(topic, k -> NonBlockingClient.create(host, clientOpts, new NonBlockingClientAdapter<Void>() {
                public void onStarted(NonBlockingClient client, Void context) {
                    logger.info("Connection started for host: " + host);
                }
            }, null));
        }
    }

    private static void createPool(String topic, String host, ClientOptions clientOpts) {
        NonBlockingClient client = NonBlockingClient.create(host, clientOpts, new NonBlockingClientAdapter<Void>() {
            public void onStarted(NonBlockingClient client, Void context) {
                logger.info("Connection started for host: " + host);
            }
        }, null);
        logger.info("Creating pool for trading partner: " + topic);
        if (connectionPool.get(topic) == null) {
            connectionPool.put(topic, client);
        }
    }

    static void freeClientFromPool(String topic) {
        synchronized (poolLock) {
            NonBlockingClient client = connectionPool.remove(topic);
            if (client != null) {
                client.stop((result, context) -> {
                    if (result.succeeded()) {
                        logger.info("Connection closed for topic: " + topic);
                    } else {
                        logger.warn("Failed to close connection for topic: " + topic);
                    }
                }, null);
            }
        }
    }

    static void clearConnectionPool() {
        synchronized (poolLock) {
            for (String topic : connectionPool.keySet()) {
                NonBlockingClient client = connectionPool.get(topic);
                if (client != null) {
                    client.stop((result, context) -> {
                        if (result.succeeded()) {
                            logger.info("Connection closed for topic: " + topic);
                        } else {
                            logger.warn("Failed to close connection for topic: " + topic);
                        }
                    }, null);
                }
            }
            connectionPool.clear();
        }
    }

    public void consumeFromAMQP() {
        getConfigurationParams();
        if (userName != null && password != null && clientPool.isEmpty()) {
            ClientOptions clientOpts = ClientOptions.builder().setCredentials(userName.trim(), password.trim()).build();
            createPool(topic, host, clientOpts);
            this.client = getClientFromPool(topic, host, clientOpts);
            if (client != null) {
                subscribeToTopic(client, topic);
            }
        }
    }

    void subscribeToTopic(NonBlockingClient client, String topic) {
        try {
            Thread.sleep(500);
            executorService.execute(() -> getConnectionService(client, null));
        } catch (InterruptedException e) {
            logger.error("Failed to subscribe to Topic: " + topic + " " + e.getMessage());
            Thread.currentThread().interrupt();
        }
    }

    public void publishToAMQP(String amqpMessage) {
        getConfigurationParams();
        if (userName != null && password != null && clientPool.isEmpty()) {
            ClientOptions clientOpts = ClientOptions.builder().setCredentials(userName.trim(), password.trim()).build();
            int retryCount = 3;
            while (retryCount > 0) {
                try { 
                    createPool(topic, host, clientOpts);
                    this.client = getClientFromPool(topic, host, clientOpts);
                    if (client != null) {
                        sendToAMQP(amqpMessage);
                        return;
                    }
                } catch (Exception e) {
                    logger.error("Failed to publish to AMQP. Retries left: " + (retryCount - 1));
                }
                retryCount--;
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            logger.error("Failed to publish to AMQP after retries.");
        }
    }

    public void sendToAMQP(String amqpMessage) {
        int maxRetries = 3;
        int retryCount = 0;
        boolean submittedSuccessfully = false;

        while (retryCount < maxRetries && !submittedSuccessfully) {
            try {
                Future<?> future = executorService.submit(() -> getConnectionService(client, amqpMessage));
                future.get(900, TimeUnit.MILLISECONDS);
                submittedSuccessfully = true;
                logger.info("Task submitted successfully to executor for AMQP message.");
            } catch (TimeoutException e) {
                logger.warn("AMQP send task submitted but didnâ€™t complete immediately: " + e.getMessage());
                submittedSuccessfully = true;
            } catch (RejectedExecutionException e) {
                retryCount++;
                logger.error("Failed to submit task to executor (retry " + retryCount + " of " + maxRetries + "): " + e.getMessage());
                try {
                    Thread.sleep(500);
                } catch (InterruptedException interruptedException) {
                    Thread.currentThread().interrupt();
                    logger.error("Retry interrupted while trying to submit to executor: " + interruptedException.getMessage());
                    break;
                }
            } catch (Exception e) {
                logger.error("Unexpected error while sending to AMQP: " + e.getMessage());
                break;
            }
        }

        if (!submittedSuccessfully) {
            logger.error("Failed to send AMQP message after " + maxRetries + " retries.");
        }
    }

    protected abstract void getConnectionService(NonBlockingClient client, String amqpMessage);

    public void stopBatchListeners() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(30, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
                if (!executorService.awaitTermination(30, TimeUnit.SECONDS)) {
                    logger.error("Executor service did not terminate");
                }
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
        cleanIdleClients();
    }

    private void cleanIdleClients() {
        synchronized (poolLock) {
            connectionPool.entrySet().removeIf(entry -> {
                NonBlockingClient client = entry.getValue();
                return client == null || client.getState() == NonBlockingClient.State.STOPPED || client.getState() == NonBlockingClient.State.ERROR;
            });
            logger.info("Cleaned up idle clients from connection pool.");
        }
    }
}
